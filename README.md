# act - WORK IN PROGRESS

*automatic configuration tree*
*autonomous configuration toolset*
*accelerated configuration transforms*

`act` is a "full-lifecycle" framework for distributed configuration management.

`act`-compatible services declare four major hooks: builders (generate a versioned *build* from an *app source*), assemblers (generate a versioned *state* from a list of *builds*), runners (generate a response from a *request* and a given *state*) and *probers* (generate *status* from a list of *success metrics*).

`act-router` implements a the `router` service, which routes requests based on state generated by it's `http` builder. This allows other services to request routes by exporting configuration for this builder.

By doing so, every service that wants to claim a new route must go through the process of publishing an *app* - a versioned package of configuration - and later generating a new versioned state for the `router`, which might be on-demand or scheduled - depending on how you configure it.

These configuration changes then go through e2e testing in a production-like environment and are then gradually distributed to live `router` instances. If any of the service-defined success metrics are disturbed according to ML-enabled projection, we automatically reverse to previous state and alert configuration publishers, resuming previous behaviour without human interaction.

Finally, services declare a *scorecard* which is the "declaration of a desired future as measured by *probers*". This allows them to create new *experiments*, consisting of proposed changes to configuration that will produce different outcomes as measured by probers.

This allows to maximize iteration speed on configuration tests without compromising on user experience. Move fast without breaking things, as a service.

## Introduction

### Some basic terms

#### Services

`act` is all about **services** - and how you can dynamically change their behaviours in a complex, distributed system in a secure manner while measuring results.

## Builders

`act` proposes a mechanism to version and deploy inter-dependent configuration for distributed services. It does that by defining how packages of configuration (*apps*) may relate to each other (e.g. *extend, depend, configure*) and providing tools to compile valid configuration for services and allow simple A/B testing of configuration.

## Example usage

## Motivation

A proof-of-concept CLI to manage **Schemas** and **Configurations** for **Services**.

### Services, Behaviors and Outcomes

When an *Enterprise* deploys *Services* (in the form of software) which their *Users* interact with, we can assume it has two basic goals:

1. That their Users have a high-quality, disruption-free user experience when interacting with said *Services*, and
2. That these interactions result in *Outcomes* which are desireable for the *Enterprise* (e.g. new sales).

In other words, a software platform is successful to the degree that it helps transform a collections of *Services* into desired business *Outcomes*.

*Outcomes* are not deterministic, since they depend on user decisions. However, *Outcomes* may be significantly influenced by changing a Service's *Behaviour* - the way in which the Service responds to *Input*.

Most Services offer some degree of control over their Behavior through *Configuration*. That means an Enterprise may alter the *Behavior* of the Services it controls by changing their *Configurations*, which in turn affects *Outcomes*.

Configurable Services need to define a *Schema*, a *Semantically Versioned* contract, through which they explicitly document *how* they can be configured.

#### Definitions

- A **Service** is any business capability packaged as software which displays consistent *Behavior* when interacting with the outside world (Users or other Services).
- A **Behavior** is the way in which a Service responds to external Input, or otherwise acts. A Behavior is usually determined, at least partially, by *Configuration*.
- An **Outcome** is a business goal which depends on *Users* interacting with *Services* (and their *Behaviors*).
- A **Configuration** is any artifact which deterministically alters the Behavior of a Service. A Configuration must follow a *Schema*.
- A **Schema** is any Service-define artifact against which any Configuration might be *Validated* in order to determine if said configuration is usable by the Service. In other words, Schemas define which Configurations are valid for a given Service.
